<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Preston's Blog]]></title><description><![CDATA[Thoughts on crypto, math, and programming.]]></description><link>http://www.prestonevans.net/</link><image><url>http://www.prestonevans.net/favicon.png</url><title>Preston&apos;s Blog</title><link>http://www.prestonevans.net/</link></image><generator>Ghost 2.9</generator><lastBuildDate>Sat, 03 Jul 2021 00:49:41 GMT</lastBuildDate><atom:link href="http://www.prestonevans.net/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[From the Archives: Pentagonal Exchange]]></title><description><![CDATA[From the archives: the original proposal for Pentagonal Exchange. Now thoroughly outdated, but maybe still interesting. 
]]></description><link>http://www.prestonevans.net/pentagonal-exchange/</link><guid isPermaLink="false">Ghost__Post__60d41963870a3238dbe34230</guid><category><![CDATA[Crypto]]></category><dc:creator><![CDATA[Preston Evans]]></dc:creator><pubDate>Thu, 24 Jun 2021 05:40:07 GMT</pubDate><media:content url="https://prestonevans.net/content/images/2021/06/pentagon.jpeg" medium="image"/><content:encoded><![CDATA[<img src="https://prestonevans.net/content/images/2021/06/pentagon.jpeg" alt="From the Archives: Pentagonal Exchange"/><p><strong><strong>A Technique for Trustless Decentralized Random Number Generation</strong></strong></p><blockquote>This post was first published in 2017 - and is now thoroughly outdated. Still, at the time, it was a pretty good idea and attracted quite a bit of attention from Ethereans. Please don't try to implement this today. Just use threshold signatures. </blockquote><p><strong><strong>Introduction:</strong></strong></p><p>Cryptocurrencies are based on the idea that individuals will act in their self interest. This makes the problem of random number generation extremely difficult. To see why this is, let’s take the example of an online lottery for some extremely large sum — maybe $10,000,000,000. Every entrant in this lottery has been assigned some “ticket number,” and the winner will be the individual whose ticket number comes out of a random number generator. Let’s also say that each ticket costs a non-trivial sum — maybe $1,000.</p><p>An obvious mechanism for decentralized random number generation is for each entrant in the lottery to pick some number, and then have the smart contract combine each of these numbers to create a seed for a random number generator. The problem here is that the last participant to submit their number controls the outcome of the drawing — they can submit any number they want and thus create any outcome that they want. All they have to do is wait until everyone else submits their numbers, and then choose a secret number of their own that produces the desired result.</p><p>To avoid this kind of cheating, RANDAO (Ethereum’s current random number generation protocol) breaks the process into two steps. First, participants publish the hash of whatever secret number they plan to submit. Then, once every participant has had an opportunity to publish a hash, the contract asks for the secret numbers. As the secret numbers are submitted the network verifies that they match the hashes provided earlier. This prevents participants from changing their minds about which number to submit, removing the final participant’s ability to rig the outcome.</p><p>However, despite this precaution one crucial weakness remains — although the final participant can’t fix the outcome, he can alter it by refusing to submit his secret number. Since the smart contract is public, we have to assume that he’ll be able to calculate the outcome and make whatever decision best suits his interests. Essentially, if he won’t win by submitting his number, he won’t submit. Since hash functions are one-way, the smart contract has no way of knowing what his secret number is and it must either 1) proceed without his contribution, 2) try again (collect a new round of hash/secret number pairs) or 3) terminate, refunding the cost of lottery tickets to each entrant.</p><p>None of these options are desirable. If we proceed without the dishonest participant’s secret number, then a malicious participant has altered the outcome of the lottery, essentially doubling his chance to win. If we try again, we haven’t addressed the weakness of the first solution — a single bad actor has still altered the outcome — and we’ve added the increased time and computation costs of a second attempt at random number generation. In addition, there’s nothing to prevent our bad actor from causing our subsequent attempts to fail in exactly the same way. Finally, if we terminate the lottery because of a single malicious participant, we open ourselves up to denial of service attacks.</p><p>Current solutions attempts to mitigate these problems by requiring participants to put in a security deposit before they submit the hash of their secret number. If participants fail to follow through by submitting their secret number at the appropriate time, the dishonest participants will have their security deposits confiscated and split among the honest participants. This approach goes a long way toward eliminating the danger of dishonesty, but it isn’t foolproof. Continuing the example from earlier — let’s say that our participant has bought a lottery ticket for $1000. RANDAO would require him to put in a relatively large security deposit- say, an extra $2000 — to participate in the random number generation. This way, if he attempts to influence the result of the lottery by failing to submit his secret number (which, as we said earlier, effectively doubles his odds of winning), his expected reward (the value of a second $1000 ticket) is outweighed by the cost of his lost security deposit ($2000).</p><p>Unfortunately, this system of incentives has one serious limitation — it’s vulnerable to Sybil attacks. To see why this is, let’s imagine a fairly powerful malicious actor. Instead of buying one ticket, he buys 100 tickets under different identities. With ninety-nine of those tickets, he acts honestly, submitting his secret numbers at the appropriate time. Now, if he knows that submitting his last secret number will make him lose the drawing, he can fail to submit and give himself an extra 100 chances to win — one for each ticket he holds. Even though he loses $2000 from his confiscated security deposit, he comes out $98,000 in the black.</p><p>With current techniques, the only way to combat this vulnerability is to increase the size of the security deposit. However, if the incentives for dishonesty are extreme enough, the deposits eventually get so large that individual actors can no longer afford to participate, and the protocol breaks down.</p><p>It should be noted that Vitalik Buterin has proposed an improved scheme called “RANDAO++” which attempts to combat this vulnerability. Rather than security deposits, this new proposal relies on limiting the timeframe for submission and computing so many sequential hashes of each secret number (say, 1,000,000,000) that no participant can possibly know the result of tampering with the generation process until after his window for action has closed. This innovation does theoretically solve the problem of tampering, but it is extraordinarily computationally expensive. Most participants will lack the hardware to themselves verify the result of the lottery within a reasonable time frame, but the gas cost of using the Ethereum Virtual Machine to verify the result would be exorbitant. This will result in centralization of trust in those interested parties who also happen to have access to massive computing power.</p><p>In this paper, I propose a new technique to solve the problem of tampering in random number generation — Pentagonal Exchange.</p><p><strong><strong>Pentagonal Exchange:</strong></strong></p><p>Step 1: Separate participants into groups of five. This can be done pseudorandomly, as there’s no significant advantage to be gained by manipulating these groupings. Assign each of the five nodes within a group an index (1–5) for reference. Again, this can be done pseudorandomly — no combination of indices has any advantage over any other combination. As in RANDAO, each contributor should submit a security deposit to help ensure good faith. Each participant establishes an encrypted connection with each other participant in his group.</p><p>Step 2: Each contributor creates a secret number (or seed) for itself. At this point, here’s what each participant knows:</p><p>1 — Secret Number 1</p><p>2 — Secret Number 2</p><p>3 — Secret Number 3</p><p>4 — Secret Number 4</p><p>5 — Secret Number 5</p><p>Step 3: Each contributor generates a second seed. Each contributor should signal the network when Step 3 is completed by publishing the hash of the two components that it generated. (For example, node 1 publishes SHA3(SN1) and SHA3(SN6)). At this point, here’s what each participant knows.</p><p>1 — Secret Numbers 1 and 6</p><p>2 — Secret Numbers 2 and 7</p><p>3 — Secret Numbers 3 and 8</p><p>4 — Secret Numbers 4 and 9</p><p>5 — Secret Numbers 5 and 10</p><p>Step 3A: Once the hash of every pair has been published, take the hash of the next complete block of the Ethereum blockchain as an eleventh input into the final seed. In most circumstances (exceptions are detailed in the last section), <em><em>this prevents even a participant who controls all five nodes from rigging the outcome of the random number generation</em></em>.</p><p><em><em>UPDATE: 11/14</em>/17 <em>— Philip Daian rightly points out that when all five nodes collude, we’ve regressed to an earlier RNG proposal in which some future block is agreed on to be the sole seed. In this case, it’s possible that a dishonest miner could find a valid block, realize that he will lose the drawing if he publishes his block, and fail to publish. This increases his chance to win. I’ve added a section to the paper to address some of these concerns.</em></em></p><p>(Note: At this point, the entire network — including our five nodes — knows SHA3(block(n+1)), as well as SHA3(SN1), SHA3(SN6), SHA3(SN2), etc.)</p><p>Step 4: Each contributor sends its first secret number to the nodes which would be two spaces counterclockwise (“left”) and one space “right” of itself if the nodes were arranged in a pentagon (see diagram below). It sends its second secret number to the nodes two spaces “right” and one “left”. Each contributor should signal the network when it has received each component.</p><figure class="kg-card kg-image-card"><img src="https://miro.medium.com/max/636/0*cnw_NTu9N_wpaLwD." class="kg-image" alt="From the Archives: Pentagonal Exchange" loading="lazy"/></figure><p>At the end of step four, here’s what each individual node knows:</p><p>Node 1 — Secret Numbers 1, 3, 5, and 7, 9, 8</p><p>Node 2 — Secret Numbers 1, 2, 4, and 8, 10, 9</p><p>Node 3 — Secret Numbers 2, 3, 5, and 9, 6, 10</p><p>Node 4 — Secret Numbers 3, 4, 1, and 10, 7, 6</p><p>Node 5 — Secret Numbers 4, 5, 2, and 6, 8, 7</p><p>Note: Even if two nodes are controlled by a single malicious entity, that adversary still doesn’t have all ten secret numbers and cannot predict what output will be generated.</p><p>Step 5: Each contributor publishes its knowledge. At this point, even if two of the five nodes decide not to publish (losing their security deposits in the process), all ten secret numbers can be transmitted to the network. If any node tries to change the value of the secret numbers it publishes, it will be found out when the network compares the hashes of these values to the hashes published after Step 3, and the offender’s security deposit will be forfeited.</p><p>Step 6: The secret numbers, along with the hash of the most recent Ethereum block, are fed into a hash function to create a seed for the random number generator. (We’ll call this seed the primary seed. For scaling purposes, the primary seed can be hashed again to create a “secondary seed.”)</p><p><strong><strong>Scaling up and down:</strong></strong></p><p>What if there aren’t exactly five participants? If there are less than five interested parties, we simply bundle groups together until we have five participants — a group of two waits for a group of three that also needs a random number, and then the five carry out Pentagonal Exchange, and each use the seed for their own purpose. If they so desire, each group can agree ahead of time to modify the seed slightly — maybe one group will use the primary seed and one group will use the secondary seed — so that they don’t have to share a random number. In high security situations, we can require a substantial proof of work from groups before they are paired. This makes Sybil attacks difficult and limits the likelihood of dishonesty. However, we should remember that even Sybil attackers who control all five nodes in a round of pentagonal exchange are unable to do anything worse than cancel the number generation.</p><p>What if we have more than five participants? Going back to our lottery example, $10,000,000,000 in tickets divided by $1,000 per ticket gives us at least 10,000,000 participants interested in choosing a random number. If we pick five participants to act as representatives pseudorandomly, we’ve simply regressed the problem. Instead, we group all of our participants into fives, and have each group carry out Pentagonal Exchange. Based on the seed generated by each group, one participant from that group is selected to serve as the representative of that group in the next round. Those representatives are grouped into fives, and the process is repeated. In this way, we can get from ten million to five representatives in only ceil(log5 (10,000,000)) = 11 steps.</p><p>(Note that when the number of participants in a round isn’t divisible by five, we need to fill up to four extra spots. We do this by sorting primary seeds from high to low. Then, working our way along the list, we select one extra participant to move into the next round from each of the top 1–4 groups. The second representative is chosen using the secondary seed. No group should be allowed to furnish more than two representatives for the subsequent round, and those two representatives should not be placed in the same group of five unless absolutely necessary.)</p><p>Once we are down to only five representatives, we carry out one final round of Pentagonal Exchange to determine the winner of the lottery. (Note: The seed generated by this final group of five is used to pick the winning ticket number out of all 10,000,000 tickets. At this point, the five representatives have no greater chance to win than anyone else).</p><p>In this way, we can securely generate a random number with participation from ten million (or more) entities. Pentagonal Exchange is relatively computationally inexpensive and, given the current Ethereum block rate of approximately 30 seconds, the whole process can be completed in about six minutes.</p><p><em><em>Author’s Note: This is the end of the original publication. In response to valid concerns about attacks through dishonest Ethereum minings, I’ve added the following section. Huge thanks to Philip Daian for pointing out this potential attack vector.</em></em></p><p><strong><strong>Preventing Ethereum Mining Attacks:</strong></strong></p><p>As laid out above, Pentagonal Exchange retains one potential weakness. When all five participants are dishonest and aware that the other participants are dishonest (i.e. when all five are controlled by one attacker), they may collude to allow ETH miners to influence the drawing. If ETH miners know that secret numbers ahead of time, they can calculate the effect of publishing valid blocks and only publish those blocks which produce the desired outcome. If the stakes are high enough, it’s possible that a significant portion of ETH hashpower could act dishonestly and someone could succeed in rigging the outcome.</p><p>To mitigate this risk, we need to do one of two things — minimize the chance that someone will benefit from controlling all five nodes, or find a source of external randomness that isn’t a blockchain. I’ll attempt to do the first in this section of the paper. I’ll attempt to tackle the second solution at a later date.</p><p>First, we should ask ourselves when an attacker benefits from controlling the outcome of the drawing. The answer — only the final round of Pentagonal Exchange. In earlier rounds, an attacker who controls all five participants in a group is guaranteed that one of his participants will move on, even if he doesn’t influence the outcome of the drawing. <em><em>He has nothing to gain by sacrificing the ETH block reward</em></em>. In the final round, however, the random number is used to pick a winner out of every participant, not just a group of five. This is where attackers will focus their efforts. It’s also important to remember that this <em><em>ETH </em></em>mining attack is only possible when all five nodes collude since the exchange of secret numbers hasn’t happened by the time the ETH block is published.</p><p>These two realizations make our job significantly simpler. We don’t need to worry about preventing dishonest mining in early rounds. In those rounds, the union of people who can attack (people who control all five nodes) and people who benefit from attacking (people who don’t control all five nodes and thus need to cheat to ensure that their node moves on) is exactly zero. This means that even in high stakes situations, the early rounds of vanilla Pentagonal Exchange should be secure.</p><p>And, if the early rounds are secure, the chances of someone controlling all five nodes in the final round are slim. For argument’s sake, let’s imagine that our would-be attacker buys about half of the 10,000,000 tickets in our drawing from the previous paper. Now, he controls roughly 50% of the participants in our pentagonal exchange. Since our early rounds are secure, Pentagonal Exchange should guarantee that the distribution of our final representatives approximates the distribution of tickets. If our adversary’s odds of controlling any one randomly selected node are 1/2, the odds of him controlling five consecutive randomly selected nodes are 1/32 = 3.125%. So, an adversary who controls half of the tickets has about a 3% chance of being able to cheat by dishonest ETH mining.</p><p>If he controls 100% of ETH hashpower, this means that in total our adversary has a 51.5625% of winning the drawing — 48.4375 (50% chance of being selected in 96.875% of drawings in which he doesn’t control all five of the final nodes) + 3.125% (100% chance of being selected in the 3.125% of drawings in which he controls all five nodes)</p><p>We should note, however, that cheating by dishonest mining doesn’t guarantee a win for our attacker unless he controls the entirety of ETH hashpower. If he controls all five PE nodes but not all the ETH hashpower, then there are three possible scenarios. 1) Someone besides our adversary wins the race to discover the next block of the ETH block chain and publishes. In this case, the adversary has gained nothing. The odds of this happening depend on the hashpower of our adversary relative to the network. 2) Our adversary wins the race, happens to discover a block that makes him win, and publishes. In this case, no attack is made — he acts indistinguishably from an honest participant. 3) Our adversary wins the race but the block he discovers will not allow him to win the drawing, so he suppresses his knowledge.</p><p>Unfortunately, the formula for calculating our adversary’s odds of winning when he doesn’t control all of the network hashpower is recursive. If he controls p percent of the total hashpower, his odds of winning outright are 48.4375% + (50% * (100-p) * 3.125%) + (50% * p * 3.125%), and his odds of suppressing his knowledge — essentially triggering a second race — are (50% * p * 3.125%). His chance of winning in a second race is [50% * (100-p) *(50% * p * 3.125%)] + [50% * p *(50% * p * 3.125%)] and his chance of triggering a third race is [50% * p *(50% * p * 3.125%)]. His chances of winning that third race are… well, you get the idea.</p><p>What this amounts to in practice is that an adversary powerful enough to buy 50% of the tickets in our lottery has between a 50% and a 51.5625% chance of winning, depending on the fraction of ETH hashpower he controls. Since we believe that no one controls 50% of the ETH network, it’s safe to assume that the actual number is closer 50% than 51.5625%. <em><em>So, in practice, even vanilla Pentagonal Exchange is extremely robust to ETH mining attacks. </em></em>However, this is an issue that should be taken extremely seriously. In the coming months, I intend to propose a system of “bootstrapped randomness” that I hope will completely eliminate the possibility of mining attacks.</p><p><strong><strong>Sixty Percent Attacks, and How to Prevent Them:</strong></strong></p><p>I’ve received several good questions about what happens when an attacker controls 3/5 of the nodes in a Pentagon. I’ll attempt to answer those questions in this section.</p><p>First, it’s crucial to remember what an attacker stands to gain in the early rounds of Pentagonal Exchange - namely, a better chance for one of his nodes to be selected to move on to the next round. This limits the scope of his attack significantly. He can’t attack when he controls one or two nodes of a Pentagon, and he won’t attack when he controls three (all three of his nodes would lose their deposits and be unable to move on). When an attacker controls all five nodes, he has nothing to gain by attacking - one of his five will move on and four won’t, no matter what he does. So, the only attacks will take place when an attacker controls four fifths of a pentagon.</p><p>We should also note that when an attacker controls 4/5 of a pentagon, he only needs to attack 20% of the time (the other 80% of the time, he is selected honestly). Since attacking requires an adversary to reveal at least three of the nodes under his control, and he wouldn’t have attacked if he controlled all five, we know that exactly one of the two remaining nodes is honest and one is dishonest. For now, let’s assume that we have some way of randomly choosing between the two remaining nodes (more on this later). We have a fifty-fifty chance of choosing the honest node which means means that our adversary has essentially raised his total odds of moving on to the next round from 80% to 90%. However, this 10% increase in chance of success costs him three security deposits in the 20% (1/5) of rounds in which he needs to cheat.</p><p>So, his cost of attacking is 3/5 of a security deposit per 10% increase in chance of winning. To compare this to his cost per chance of buying tickets, let’s multiply both sides by ten. At this rate, our attacker is paying 30/5 (or 6) security deposits per additional 100% chance of winning. However, his ticket cost of a guaranteed win is only 5. So, as long as security deposits are at least 5/6 of the ticket price, our adversary really hasn’t gained anything. For extra security, let’s set them at the full price of a ticket.</p><p>Now that the early rounds are secure, how do we go about securing the final round? Well, as we discussed earlier, later rounds are composed of a probabilistically representative group of participants when the early rounds are secure. This means that in order for someone to control a 3/5 majority of the final round they (probably) need to buy about 60% of the tickets in our lottery.</p><p>But if they an attacker buys 60% of the tickets, he also has to pay 60% of the total security deposits. If we go with the one-to-one ticket price to security deposit ratio, we calculate that this attackers initial input to the lottery was 120% of the jackpot. This is worthwhile to the adversary because he expects to get all of his security deposits back, but we can use it to our advantage.</p><p>Since his 3/5 majority is only enough to cancel and not rig the final round of our drawing (recall that Pentagonal Exchange requires him to commit to secret numbers before he can predict who will win the drawing), our adversary has to decide what to do in the 40% of drawings that he isn’t going to win. He doesn’t want someone else to win, so he’ll be tempted to refuse to publish his secret numbers. If he does, the network is stuck several inputs short of being able to generate a random number.</p><p>How do we prevent this from happening? The good news is, we don’t have to. As long as we hold on to everyone’s security deposit until the last round comes through, our adversary will never have an incentive to attack. Recall that our adversary has bought 60% of the tickets and paid 60% of the security deposits. He’s paid more than the jackpot (and more than everyone else combined) into the system. That means that if he refuses to submit his secret numbers, he’s lost more money than the entire rest of the network has, combined. More importantly, he hasn’t changed the outcome of the drawing. If we go back to our lottery example from earlier, our adversary will have burned twelve billion dollars, and have nothing to show for it. This makes his rational response painfully clear. He has to publish his secret numbers and salvage his security deposits, and our system remains secure.</p><p>Now, there’s just one more point to touch on - if three nodes in an early pentagon fail to submit, how do we choose between the two that are left? There isn’t a perfect answer to this question, but I think that in practice, using some permutation of the next block of the ETH blockchain would turn out to be close enough to random for our purposes. Yes, a dishonest miner could theoretically withhold a valid block to give his node a better chance at being selected, but he has to burn three security deposits just to get to a point where he can mine dishonestly. Even then, he can only increase his chance of being selected from fifty-fifty to 75%. So, in practice, sacrificing the ETH block reward probably won’t be worthwhile. However, this is certainly an area where there’s room for improvement — it’s likely that some provably perfect solution exists, I just haven’t found it yet.</p><p><em><em>Author’s Note: This entire paper, and especially the final section, represents an idea in its earliest stages — please feel free to contact me with technical critiques and don’t hesitate to point out any errors in logic.</em></em></p>]]></content:encoded></item><item><title><![CDATA[Ava is no ETH-killer]]></title><description><![CDATA[If you're going to build a Dapp, don't do it on Avalanche. ]]></description><link>http://www.prestonevans.net/ava-bad/</link><guid isPermaLink="false">Ghost__Post__60ce0b5818c9b5df0d35a610</guid><category><![CDATA[Crypto]]></category><dc:creator><![CDATA[Preston Evans]]></dc:creator><pubDate>Mon, 21 Jun 2021 23:42:09 GMT</pubDate><media:content url="https://prestonevans.net/content/images/2021/06/frozen_landscape.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://prestonevans.net/content/images/2021/06/frozen_landscape.jpg" alt="Ava is no ETH-killer"/><p>If you're building a Dapp today, there can be good reasons to look at launching on a platforms besides Ethereum. ETH has high fees, it's time to finality is long, and there's MEV to worry about. But if you're going to build a production Dapp on another platform, please <em>please</em>, don't use Avalanche. </p><p>Avalanche has 3 significant shortcomings, any one of which could be enough to doom a platform.</p><ol><li>Even in theory, it can't maintain <strong><em>liveness</em></strong> without centralization.</li><li>In practice, it may not even guarantee <strong><em>safety</em></strong>.</li><li>It doesn't solve the <strong><em>state-growth problem</em></strong>.</li></ol><h2 id="alive-in-theory">Alive, in theory</h2><h3 id="odarn">O(<em>darn</em>)</h3><p>According to its <a href="https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf">whitepaper</a>, Avalanche provides the following guarantee about liveness: </p><blockquote>P3. Liveness (Strong Form). If f ≤ O( √n), then the Snow protocols terminate with high probability (≥ 1−ε) in O(log n) rounds. (Blogger's Note: the <em>"f"</em> in this statement refers to the number of adversarial nodes.)</blockquote><p>In vanilla distributed systems research, this is a perfectly reasonable guarantee to provide. Unfortunately, it's not a good guarantee for a cryptosystem that wants to be meaningfully decentralized. Why not? I'm so glad you asked! </p><p>Imagine an Ava network with 25 nodes. According to the whitepaper, that network can tolerate √25 = 5 malicious nodes without experiencing a liveness failure. For the mathematically inclined, that's 20% malicious nodes (or stake, or whatever). That guarantee is <em>significantly</em> worse than the one provided Bitcoin (which keeps liveness up to ~51% malicious nodes), but is sort of in the ballpark of BFT protocols which tolerate 33% byzantine nodes before experiencing a safety or liveness failure. Unfortunately, the story doesn't end here.</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I&#39;ve been saying some of this stuff, much more nicely, for years. <br><br>The right substrate for all PoS coins is Avalanche. It&#39;s super fast, it scales, and it enables tens of thousands to millions of nodes to participate in the protocol. Come check it out. <a href="https://t.co/mgbhV1mZtL">https://t.co/mgbhV1mZtL</a></br></br></p>&mdash; Emin Gün Sirer (@el33th4xor) <a href="https://twitter.com/el33th4xor/status/1309158257055993858?ref_src=twsrc%5Etfw">September 24, 2020</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
</figure><p>As Ava scales up, its liveness guarantee gets proportionally worse. At 100 nodes, an Ava network can only tolerate 10% of its nodes acting maliciously. At its current scale (about 1000 nodes), only 3% can be malicious without jeopardizing liveness. At the "tens of thousands of nodes" scale that its inventors <a href="https://twitter.com/el33th4xor/status/1309158257055993858">promise on Twitter</a>, an adversary controlling even 1% of stake can bring the network to a halt. And, unlike most proof-of-stake protocols, <a href="https://twitter.com/el33th4xor/status/1382721311814868996">Ava doesn't have a mechanism</a> to identify and slash the adversaries. Game over.</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Avalanche does not have slashing. <a href="https://t.co/j4GQXYn0Jm">https://t.co/j4GQXYn0Jm</a></p>&mdash; Emin Gün Sirer (@el33th4xor) <a href="https://twitter.com/el33th4xor/status/1382721311814868996?ref_src=twsrc%5Etfw">April 15, 2021</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
</figure><h3 id="non-zero-probability-of-success">Non-zero Probability of Success</h3><p>But, as I can already hear the Ava defenders protesting, the whitepaper provides another liveness guarantee: </p><blockquote>P2. Liveness (Upper Bound). Snow protocols terminate with a strictly positive probability within \(t_max\) rounds.</blockquote><p>Unfortunately, the statement that an algorithm "terminates with strictly positive probability" is meaningless as a guarantee about a system's behavior. After all, the probability that the computer you're reading this on will spontaneously re-assemble itself into a sculpture of Satoshi Nakamoto is also "strictly positive". Non-zero probability of your Dapp working is not a guarantee you should be comfortable with. I know it seems like I'm just being pedantic here. I'm really not trying to be. This is deeply important. </p><p>As the fraction of nodes (or stake, or whatever), controlled by the attacker exceeds that  √n upper bound, the performance of Avalanche gets poorer and poorer. Exactly how quickly performance degrades is not clear from the whitepaper - it says that the slowdown is polynomial when <em>f</em> exceeds √n but becomes exponential as <em>f</em> approaches \(\frac{n}{2}\) - but even a polynomial increase in communication is really bad.  </p><p>Remember, we're talking about thousands of nodes here - if each node has to send and receive a small polynomial number of messages (say, \(n^2\) ), that translates to <em><strong>millions</strong></em> of messages <em><strong>per decision</strong></em>. That won't work. Even if the slowdown is polynomial, a decentralized Ava network is dead in the water. </p><h2 id="danger-close">Danger Close!</h2><p>As it turns out, there's an even more worrying development on the horizon. <a href="https://twitter.com/SarahJamieLewis">Sarah Jamie Lewis</a> of Open Privacy recently published (and formally verified) <a href="https://git.openprivacy.ca/sarah/formal-verification/raw/branch/master/snowfall.pdf">an attack on Snow-family consensus protocols</a> which purports to break the safety and liveness guarantees of Ava's underlying consensus algorithm. </p><blockquote>Through probabilistic modelling (sic) we formally verify an adversarial strategy that forces correct nodes to choose between safety and liveness even when f &lt; O( √n).</blockquote><p>If you develop on Avalanche, this should make you really nervous.  Avalanche claims to provide strong guarantees of safety and liveness as long as the attacker controls less than √n nodes. If those guarantees can really be broken, even in a contrived setup, then there's something wrong with the whitepaper. Remember, a single error contaminates the entire security proof. If the Ava whitepaper is 99% correct, it's 100% wrong.</p><p>I want to be clear: this doesn't necessarily mean that Ava is not secure. It means that we don't know whether Ava is secure or not. That's ok - research takes time. But it's not ok to build a production app on a system that might be fundamentally broken. Not if there's another option. </p><h2 id="tradeoffs-the-good-the-bad-and-the-downright-weird">Tradeoffs: The Good, the Bad, and the Downright Weird</h2><p>This brings me to my final point. When you're designing a complex system, you're often forced to accept a trade off between two desirable properties. Like all blockchain projects, Ava chose a set of tradeoffs that its designers found compelling - it traded away some security guarantees to secure faster consensus. But here's the rub: <em>consensus was never the bottleneck to begin with</em>! The real bottleneck in modern blockchains is state growth. </p><p>In Ethereum, each read or write into the <em>database</em> incurs seven or eight random disk accesses (because the database uses a trie structure internally), and each<em> state access</em> incurs seven or eight random <em>database</em> accesses in the course of traversing the state trie. </p><p>For those of you who haven't spent time a lot of optimizing computer programs, that's what we in the business call "really bad". Random disk accesses are <strong><em>SLOW</em></strong>. In the time it takes to do a single random read, a CPU might be able perform 10,000 computations. This is why your full node can take a long time to sync even though the CPU is mostly idle. The time it takes to sync a full node is typically dominated by disk accesses.</p><p>But remember how I said that each database access takes seven or eight writes, and each state access takes seven or eight database accesses? It turns out that both of those numbers grow with the size of a blockchain's state. Specifically, they're each about log(s) where S is the state size. So the time it takes to process a transaction grows with \(log^2(s)\). The next time Ethereum state size doubles, the time it takes to process a given transaction will increase by roughly 30%. This is why Ethereum keeps the block gas limit low - it needs to limit both block processing times and state growth. </p><p>As long everyone can process every candidate transaction, coming to consensus is relatively easy. There are already dozens of consensus protocols which offer fast finality. But if state size grows too quickly, processing transactions on commodity hardware becomes impossible. It's processing blocks that's the bottleneck, not coming to consensus. (And in case you were wondering, the Avalanche-go client relies on Ethereum's Geth - so all of these limitations really do apply to Ava.)</p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">The discussion was raised on the context of scaling, people saying that AVAX is better than Ethereum because it scales. I pointed out that it uses Geth under the hood. From the contextual perspective, you are changing the topic.</p>&mdash; Péter Szilágyi (karalabe.eth) (@peter_szilagyi) <a href="https://twitter.com/peter_szilagyi/status/1358654546646626304?ref_src=twsrc%5Etfw">February 8, 2021</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
</figure><p>So, to recap, Ava trades safety and/or liveness guarantees for speed of consensus, but consensus was never the bottleneck. That's like taking the engine out of a motorcycle to give it more cargo space. It's not illegal, just... not a good tradeoff. </p><h2 id="conclusion-building-on-ava-considered-harmful">Conclusion: Building on Ava Considered Harmful</h2><p>Not everyone wants to build on Ethereum. That's good and healthy. We live in a multi-chain world. But please, for the love of all that is holy, stop treating Avalanche like a production system. Ava may be a cool distributed systems research project, but it's not a good place to build mission critical applications. Its safety and liveness guarantees are much weaker than those of other projects, and it might have a fundamental consensus flaw. Besides, even if it works, it doesn't solve the scaling problem. </p><p><em>Author's Note: Did I get some things wrong? Almost certainly. If you find one, please feel free to reach out on Twitter. I'm happy to issue corrections or retractions as necessary. </em></p><h3 id="psto-the-folks-at-ava-labs">P.S. - To the Folks at Ava Labs</h3><p>Like all blockchains, Ava has its share of evangelists  - and that's ok. But <strong><u><em>please</em></u></strong> be careful making claims like <a href="https://twitter.com/el33th4xor/status/1316471519640465411">this</a> on Twitter. Ava is <em>not</em> live with 49% honest nodes unless you define "live" as "having arbitrarily small but non-zero probability of advancing". At best, you're just going to confuse a lot of newcomers. Ava isn't another IOTA, but this kind of rhetoric is how you would turn it into one. </p><figure class="kg-card kg-embed-card"><blockquote class="twitter-tweet"><p lang="en" dir="ltr">I can talk about Avalanche. Avalanche has a parameterizable decision protocol that can withstand huge attackers, even 80%, with safety, but not liveness. It requires 51% honest nodes for liveness and safety together. And its bootstrap requires 51%.</p>&mdash; Emin Gün Sirer (@el33th4xor) <a href="https://twitter.com/el33th4xor/status/1316471519640465411?ref_src=twsrc%5Etfw">October 14, 2020</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"/>
</figure><p/><p/>]]></content:encoded></item></channel></rss>